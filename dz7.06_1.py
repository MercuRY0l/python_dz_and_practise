# Для заданного целочисленного массива nums верните все тройки [nums[i], nums[j], nums[k]] 
# такие, что i != j, i != k, и j != k, и nums[i] + nums[j] + nums[k] == 0.
 
# Обратите внимание, что набор решений не должен содержать повторяющихся троек.
 
# Пример 1:
 
# Входные данные: nums = [-1,0,1,2,-1,-4]
# Выходные данные: [[-1,-1,2],[-1,0,1]]
# Объяснение:
# nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
# nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
# nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
#  Отдельные тройки — это [-1,0,1] и [-1,-1,2].
#  Обратите внимание, что порядок вывода и порядок троек не имеют значения.
# Пример 2:
 
# Ввод: nums = [0,1,1]
# Вывод: []
# Объяснение: Единственный возможный триплет не даёт в сумме 0.
# Пример 3:
 
# Ввод: nums = [0,0,0]
# Вывод: [[0,0,0]]
# Объяснение: Единственная возможная тройка чисел в сумме даёт 0.
 
 
nums = [-1,0,1,2,-1,-4]

list_num = []

for i in range (len(nums)):
    for j in range (i+1, len(nums)):
        for k in range (j+1, len(nums)):
            if (i != j and i!=k and j!= k and nums[i] + nums[j] + nums[k] == 0):
                res = [nums[i], nums[j], nums[k]]
                
                if res == [0,0,0]:
                    break
                
                if res not in list_num:
                    list_num.append(res)
                
                            
print(list_num)
